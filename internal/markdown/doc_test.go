package markdown

import (
	"github.com/reakaleek/gh-action-readme/internal/action"
	"github.com/stretchr/testify/assert"
	"regexp"
	"strings"
	"testing"
)

func TestDoc(t *testing.T) {
	// arrange
	doc := Doc{
		lines: []string{
			"Hello,",
			"!",
		},
	}

	// act
	doc.insertAfterPrefix("Hello", "World")

	// assert
	assert.Equal(t, "Hello,\nWorld\n!", doc.ToString())
}

func TestInsertSection(t *testing.T) {
	// arrange
	doc := Doc{
		lines: []string{
			"<!-- title -->",
			"World",
		},
	}

	// act
	doc.insertSection("title", "# Hello")
	// assert
	assert.Equal(t, "<!-- title -->\n# Hello\n<!--/title-->\nWorld", doc.ToString())
}

func TestRemoveSection(t *testing.T) {
	// arrange
	doc := Doc{
		lines: []string{
			"<!-- title -->",
			"# Hello",
			"<!-- /title -->",
			"World",
		},
	}

	// act
	doc.clearSection("title")

	// assert
	assert.Equal(t, "<!-- title -->\nWorld", doc.ToString())
}

func TestDiff(t *testing.T) {
	// arrange
	doc := Doc{
		lines: []string{"Hello, World"},
	}
	otherDoc := Doc{
		lines: []string{"Hello, World!"},
	}

	// act
	diff := doc.Diff(&otherDoc)

	// assert - new unified diff format
	assert.Contains(t, diff.PrettyDiff, "Hello, World")
	assert.Contains(t, diff.PrettyDiff, "+")
	assert.Contains(t, diff.PrettyDiff, "!")
}

func TestDiffTrue(t *testing.T) {
	// arrange
	doc := Doc{
		lines: []string{"Hello, World"},
	}
	otherDoc := Doc{
		lines: []string{"Hello, World!"},
	}

	// act
	diff := doc.Diff(&otherDoc)

	// assert
	assert.True(t, diff.HasDiff)
}

func TestDiffFalse(t *testing.T) {
	// arrange
	doc := Doc{
		lines: []string{"Hello, World!"},
	}
	otherDoc := Doc{
		lines: []string{"Hello, World!"},
	}

	// act
	diff := doc.Diff(&otherDoc)

	// assert
	assert.False(t, diff.HasDiff)
}

func TestSingleLineSection(t *testing.T) {
	// arrange
	doc := Doc{
		lines: []string{
			"<!-- name --><!-- /name -->",
		},
	}

	// act
	doc.updateName("Foo")

	// assert
	assert.Equal(t, "<!-- name -->Foo<!-- /name -->", doc.ToString())
}

func TestGetAttribute(t *testing.T) {
	// arrange
	line := "<!--usage action=\"elastic/oblt-actions/test\" version=\"v2\"-->"

	// act
	action, _ := getAttribute(line, "action")
	version, _ := getAttribute(line, "version")

	// assert
	assert.Equal(t, "elastic/oblt-actions/test", action)
	assert.Equal(t, "v2", version)
}

func TestStartCommentPattern(t *testing.T) {
	// arrange
	pattern := startCommentPattern("usage")
	re := regexp.MustCompile(pattern)
	line := "<!--usage-->"

	// act
	result := re.MatchString(line)

	// assert
	assert.True(t, result)
}

func TestStartCommentPattern2(t *testing.T) {
	// arrange
	pattern := startCommentPattern("usage")
	re := regexp.MustCompile(pattern)
	line := "<!--usage action=\"action\" version=\"v1\"-->"

	// act
	result := re.MatchString(line)

	// assert
	assert.True(t, result)
}

func TestUpdateUsage(t *testing.T) {
	// arrange
	t.Setenv("VERSION", "v2")
	doc := Doc{
		lines: []string{
			"<!-- usage action=\"elastic/oblt-actions/test\" version=\"env:VERSION\" -->",
			"```yaml",
			"    uses: elastic/oblt-actions/test@v1",
			"```",
			"<!--/usage-->",
		},
	}

	// act
	err := doc.UpdateUsage(nil)

	// assert
	assert.NoError(t, err)
	assert.Equal(t, "<!-- usage action=\"elastic/oblt-actions/test\" version=\"env:VERSION\" -->\n```yaml\n    uses: elastic/oblt-actions/test@v2\n```\n<!--/usage-->", doc.ToString())
}

func TestUpdate(t *testing.T) {
	// arrange
	doc := Doc{
		lines: []string{
			"<!--name--><!--/name-->",
			"<!--description-->",
			"<!--inputs-->",
			"<!--outputs-->",
			"<!-- usage action=\"elastic/oblt-actions/test\" version=\"v1\" -->",
			"```yaml",
			"    uses: elastic/oblt-actions/test@main",
			"```",
			"<!--/usage-->",
		},
	}

	a := action.New(
		"Test",
		"Author",
		"Test description.",
		action.Inputs{
			"input1": action.Input{
				Description: "input1 description.",
				Required:    true,
			},
		},
		[]string{"input1"},
		action.Outputs{
			"output1": action.Output{
				Description: "output1 description.",
			},
		},
		[]string{"output1"},
	)

	// act
	err := doc.Update(a)
	assert.NoError(t, err)

	// assert
	expected := strings.Join([]string{
		"<!-- Generated by https://github.com/reakaleek/gh-action-readme -->",
		"<!--name-->Test<!--/name-->",
		"<!--description-->",
		"Test description.",
		"<!--/description-->",
		"<!--inputs-->",
		"| Name     | Description         | Required | Default |",
		"|----------|---------------------|----------|---------|",
		"| `input1` | input1 description. | `true`   | ` `     |",
		"<!--/inputs-->",
		"<!--outputs-->",
		"| Name      | Description          |",
		"|-----------|----------------------|",
		"| `output1` | output1 description. |",
		"<!--/outputs-->",
		"<!-- usage action=\"elastic/oblt-actions/test\" version=\"v1\" -->",
		"```yaml",
		"    uses: elastic/oblt-actions/test@v1",
		"```",
		"<!--/usage-->",
	}, "\n")

	assert.Equal(t, expected, doc.ToString())

}

func TestCopy(t *testing.T) {
	// arrange
	doc := Doc{
		lines: []string{"Hello, World"},
	}

	// act
	duplicate := doc.Copy()

	// assert
	assert.Equal(t, doc.ToString(), duplicate.ToString())

}

func TestEnsureGeneratedCommentAddsWhenMissing(t *testing.T) {
	// arrange
	doc := Doc{
		lines: []string{
			"# <!--name-->Test<!--/name-->",
			"<!--description-->",
		},
	}

	// act
	doc.ensureGeneratedComment()

	// assert
	assert.Equal(t, "<!-- Generated by https://github.com/reakaleek/gh-action-readme -->", doc.lines[0])
	assert.Equal(t, 3, len(doc.lines))
}

func TestEnsureGeneratedCommentDoesNotDuplicateWhenExists(t *testing.T) {
	// arrange
	doc := Doc{
		lines: []string{
			"<!-- Generated by https://github.com/reakaleek/gh-action-readme -->",
			"# <!--name-->Test<!--/name-->",
			"<!--description-->",
		},
	}

	// act
	doc.ensureGeneratedComment()

	// assert
	assert.Equal(t, "<!-- Generated by https://github.com/reakaleek/gh-action-readme -->", doc.lines[0])
	assert.Equal(t, 3, len(doc.lines))
}

func TestNewEmptyDoc(t *testing.T) {
	// arrange & act
	doc := NewEmptyDoc("test.md")

	// assert
	assert.Equal(t, "test.md", doc.name)
	assert.Equal(t, 0, len(doc.lines))
	assert.Equal(t, "", doc.ToString())
}

func TestNewDocOrCreate_FileExists(t *testing.T) {
	// arrange & act
	doc, err := NewDocOrCreate("testdata/1-README-in.md")

	// assert
	assert.NoError(t, err)
	assert.NotNil(t, doc)
	assert.Greater(t, len(doc.lines), 0)
}

func TestNewDocOrCreate_FileDoesNotExist(t *testing.T) {
	// arrange & act
	doc, err := NewDocOrCreate("nonexistent-file.md")

	// assert
	assert.NoError(t, err)
	assert.NotNil(t, doc)
	
	// Verify template structure
	str := doc.ToString()
	assert.Contains(t, str, "<!--name--><!--/name-->")
	assert.Contains(t, str, "<!--description-->")
	assert.Contains(t, str, "<!--/description-->")
	assert.Contains(t, str, "## Inputs")
	assert.Contains(t, str, "<!--inputs-->")
	assert.Contains(t, str, "<!--/inputs-->")
	assert.Contains(t, str, "## Outputs")
	assert.Contains(t, str, "<!--outputs-->")
	assert.Contains(t, str, "<!--/outputs-->")
	assert.Contains(t, str, "## Usage")
}

func TestDiffEmptyWithContent(t *testing.T) {
	// Test the fix: empty doc vs content should show HasDiff=true
	// arrange
	emptyDoc := NewEmptyDoc("test.md")
	contentDoc := Doc{
		lines: []string{"Some content"},
	}

	// act
	diff := emptyDoc.Diff(&contentDoc)

	// assert
	assert.True(t, diff.HasDiff, "Empty doc vs content should have diff")
	assert.Contains(t, diff.PrettyDiff, "Some content")
}

func TestUpdatePreservesEmptyLines(t *testing.T) {
	// Test that empty lines between sections are preserved
	// arrange
	doc := Doc{
		lines: []string{
			"# <!--name--><!--/name-->",
			"<!--description-->",
			"<!--/description-->",
			"",  // Empty line should be preserved
			"## Inputs",
			"<!--inputs-->",
			"<!--/inputs-->",
			"",  // Empty line should be preserved
			"## Outputs",
			"<!--outputs-->",
			"<!--/outputs-->",
		},
	}

	a := action.New(
		"Test",
		"Author",
		"Test description.",
		action.Inputs{},
		[]string{},
		action.Outputs{},
		[]string{},
	)

	// act
	err := doc.Update(a)

	// assert
	assert.NoError(t, err)
	str := doc.ToString()
	
	// Check that empty lines exist between sections
	lines := strings.Split(str, "\n")
	
	// Find the line after <!--/description--> and check it's empty
	for i, line := range lines {
		if strings.Contains(line, "<!--/description-->") {
			if i+1 < len(lines) {
				assert.Equal(t, "", lines[i+1], "Empty line should exist after description")
			}
		}
		if strings.Contains(line, "<!--/inputs-->") {
			if i+1 < len(lines) {
				assert.Equal(t, "", lines[i+1], "Empty line should exist after inputs")
			}
		}
	}
}
